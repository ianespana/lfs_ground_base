{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome Heracles' LFS Ground Vehicle Base is a comprehensive vehicle base for building Garry's Mod ground vehicles that utilize the power of LFS. Please note this base does NOT contain any vehicles and is merely something that must be built upon!","title":"LFS Ground Base Documentation"},{"location":"#welcome","text":"Heracles' LFS Ground Vehicle Base is a comprehensive vehicle base for building Garry's Mod ground vehicles that utilize the power of LFS. Please note this base does NOT contain any vehicles and is merely something that must be built upon!","title":"Welcome"},{"location":"breaking_changes/","text":"Breaking Changes This is an ordered list of braking changes. Changes in this section will probably break your code if you overrode any functions not specified as overridable in this documentation. 7/6/2022 - V 2.0.0 Changes to the vector math used to align vehicles with the ground. Vehicles now correctly rotate to match the ground's inclination. If you have previous overriden the OnTick function your script WILL BREAK . Please use the new OnTickExtra function! Vehicles now use more than one trace to calculate a smoother rotation between surfaces. This should result in smoother riding and better transitions from one surface to another. If you have previous overriden the OnTick function your script WILL BREAK . Please use the new OnTickExtra function! The default shadow params for movement were updated, giving a faster response for vehicles with no custom params. If you have been using the default shadow params your vehicle will probably have insane speed now. Just decrese the move/boost speed to fix.","title":"Breaking Changes"},{"location":"breaking_changes/#breaking-changes","text":"This is an ordered list of braking changes. Changes in this section will probably break your code if you overrode any functions not specified as overridable in this documentation.","title":"Breaking Changes"},{"location":"breaking_changes/#762022-v-200","text":"Changes to the vector math used to align vehicles with the ground. Vehicles now correctly rotate to match the ground's inclination. If you have previous overriden the OnTick function your script WILL BREAK . Please use the new OnTickExtra function! Vehicles now use more than one trace to calculate a smoother rotation between surfaces. This should result in smoother riding and better transitions from one surface to another. If you have previous overriden the OnTick function your script WILL BREAK . Please use the new OnTickExtra function! The default shadow params for movement were updated, giving a faster response for vehicles with no custom params. If you have been using the default shadow params your vehicle will probably have insane speed now. Just decrese the move/boost speed to fix.","title":"7/6/2022 - V 2.0.0"},{"location":"code_overview/","text":"Code Overview All ground base vehicles follow the basic Garry's Mod SENT structure and are comprised of 3 main parts: entity_identifier/ # The unique ID for this entity. shared.lua # Code that executes on the server and on the client. init.lua # Code that executes on the server. cl_init.lua # Code that executes on the client. Entities can also be created using a single Lua file, however it is recommended to keep them separate to reduce the chances of confusion and to keep the code cleaner. shared.lua This file is where the majority of the configuration is defined. In here we define our vehicle's name, model, category, and other things. This is also where we tell our code to utilize the ground base. This documentation will not go into all the options associated with creating SENTs, but rather the specific options that can be configured with the ground base. It is important to note that you do NOT need to change all of these settings! Most of them come preconfigured by default, and changing them is only necessary if you want to tweak their values. init.lua This file is where all the server-side code is processed. It is responsible for handling vehicle movement, weapons, animations, etc. cl_init.lua This file is where all the client-side code is processed. It is responsible for handling HUD painting, VFX, lights, etc.","title":"Code Overview"},{"location":"code_overview/#code-overview","text":"All ground base vehicles follow the basic Garry's Mod SENT structure and are comprised of 3 main parts: entity_identifier/ # The unique ID for this entity. shared.lua # Code that executes on the server and on the client. init.lua # Code that executes on the server. cl_init.lua # Code that executes on the client. Entities can also be created using a single Lua file, however it is recommended to keep them separate to reduce the chances of confusion and to keep the code cleaner.","title":"Code Overview"},{"location":"code_overview/#sharedlua","text":"This file is where the majority of the configuration is defined. In here we define our vehicle's name, model, category, and other things. This is also where we tell our code to utilize the ground base. This documentation will not go into all the options associated with creating SENTs, but rather the specific options that can be configured with the ground base. It is important to note that you do NOT need to change all of these settings! Most of them come preconfigured by default, and changing them is only necessary if you want to tweak their values.","title":"shared.lua"},{"location":"code_overview/#initlua","text":"This file is where all the server-side code is processed. It is responsible for handling vehicle movement, weapons, animations, etc.","title":"init.lua"},{"location":"code_overview/#cl_initlua","text":"This file is where all the client-side code is processed. It is responsible for handling HUD painting, VFX, lights, etc.","title":"cl_init.lua"},{"location":"debugging/","text":"Debugging Debugging your ground base vehicle is simple. All you have to do is turn on developer mode. This can be done by using the developer 1 command in the console. Once that is done you will see the following overlay: Breakdown Center Plane The white plane indicates our model's boundary box. This is where all ray casts start. The plane is positioned at center of the model's bounding box. Ray-cast Origins The cyan/yellow spheres indicate the exact position where a ray-cast starts from. The amount of spheres varies depending on our vehicle's trace subdivisions . Cyan spheres indicate that the ray-cast did not hit any solid ground (or water). Yellow spheres indicate we successfully detected the ground at that position. Ray-cast Hit Positions The cyan/yellow planes indicate the exact position where a ray-cast ended. The amount of planes varies depending on our vehicle's trace subdivisions . Cyan planes indicate that the ray-cast did not hit any solid ground (or water). Yellow planes indicate we successfully detected the ground at that position. Alignment Axes The red/green/blue lines indicate the axes our vehicle is currently aligned with in 3D space. This is calculated by getting the average normal direction of all planes hit by our ray-casts. The axes will only appear when at least one ray-cast successfully hit solid ground (or water), and their position indicates the average hit position of all our ray-casts. Usage The debug overlay can be used to know how your vehicle is behaving. The center plane will expand and contract based on your look ahead configuration, the ray-cast planes will individually adjust to show you how the terrain is affecting your vehicle, and the alignment axes will be useful to know what your vehicle is considering to be ground, as well as it's rotation.","title":"Debugging"},{"location":"debugging/#debugging","text":"Debugging your ground base vehicle is simple. All you have to do is turn on developer mode. This can be done by using the developer 1 command in the console. Once that is done you will see the following overlay:","title":"Debugging"},{"location":"debugging/#breakdown","text":"","title":"Breakdown"},{"location":"debugging/#center-plane","text":"The white plane indicates our model's boundary box. This is where all ray casts start. The plane is positioned at center of the model's bounding box.","title":"Center Plane"},{"location":"debugging/#ray-cast-origins","text":"The cyan/yellow spheres indicate the exact position where a ray-cast starts from. The amount of spheres varies depending on our vehicle's trace subdivisions . Cyan spheres indicate that the ray-cast did not hit any solid ground (or water). Yellow spheres indicate we successfully detected the ground at that position.","title":"Ray-cast Origins"},{"location":"debugging/#ray-cast-hit-positions","text":"The cyan/yellow planes indicate the exact position where a ray-cast ended. The amount of planes varies depending on our vehicle's trace subdivisions . Cyan planes indicate that the ray-cast did not hit any solid ground (or water). Yellow planes indicate we successfully detected the ground at that position.","title":"Ray-cast Hit Positions"},{"location":"debugging/#alignment-axes","text":"The red/green/blue lines indicate the axes our vehicle is currently aligned with in 3D space. This is calculated by getting the average normal direction of all planes hit by our ray-casts. The axes will only appear when at least one ray-cast successfully hit solid ground (or water), and their position indicates the average hit position of all our ray-casts.","title":"Alignment Axes"},{"location":"debugging/#usage","text":"The debug overlay can be used to know how your vehicle is behaving. The center plane will expand and contract based on your look ahead configuration, the ray-cast planes will individually adjust to show you how the terrain is affecting your vehicle, and the alignment axes will be useful to know what your vehicle is considering to be ground, as well as it's rotation.","title":"Usage"},{"location":"examples/","text":"Examples Sample vehicles can be found here . Feel free to disect them and experiment with them. They show how to use the ground base for small, medium and large vehicles. BARC Speeder AAT MTT","title":"Examples"},{"location":"examples/#examples","text":"Sample vehicles can be found here . Feel free to disect them and experiment with them. They show how to use the ground base for small, medium and large vehicles.","title":"Examples"},{"location":"examples/#barc-speeder","text":"","title":"BARC Speeder"},{"location":"examples/#aat","text":"","title":"AAT"},{"location":"examples/#mtt","text":"","title":"MTT"},{"location":"faq/","text":"Frequently Asked Questions Welcome to the Heracles' LFS Ground Vehicle Base documentation. If new to the base, start with the features and installation documents . How do I create a vehicle? Head over to Code Overview to get started on your own vehicles. Where do I submit bug reports/suggestions? Please use the Issues section of GitHub to report bugs or file suggestions.","title":"Frequently Asked Questions"},{"location":"faq/#frequently-asked-questions","text":"Welcome to the Heracles' LFS Ground Vehicle Base documentation. If new to the base, start with the features and installation documents .","title":"Frequently Asked Questions"},{"location":"faq/#how-do-i-create-a-vehicle","text":"Head over to Code Overview to get started on your own vehicles.","title":"How do I create a vehicle?"},{"location":"faq/#where-do-i-submit-bug-reportssuggestions","text":"Please use the Issues section of GitHub to report bugs or file suggestions.","title":"Where do I submit bug reports/suggestions?"},{"location":"features/","text":"Features Heracles' ground base has several compelling features: High precision movement. Heracles' ground base utilizes a series of ray casts to determine the best positioning of a vehicle in relation to it's size and the ground underneath. The amount of ray casts used can be configured on a per-vehicle basis, allowing developers to fine tune their vehicles for optimal performance. Configuration via simple files. Heracles' ground base handles all the complex logic behind the scenes, allowing developer's to easily create vehicles by simply modifying a couple of variables in their entity script. Flexibility. Almost every function and parameter of Heracles' ground base is set up to provide a high degree of flexibility. Want to add your own code to run every tick? We're got you covered. Want to change the way your vehicle behaves under certain conditions? No problem! All the settings used by the ground base can be easily changed to suit your needs.","title":"Features"},{"location":"features/#features","text":"Heracles' ground base has several compelling features: High precision movement. Heracles' ground base utilizes a series of ray casts to determine the best positioning of a vehicle in relation to it's size and the ground underneath. The amount of ray casts used can be configured on a per-vehicle basis, allowing developers to fine tune their vehicles for optimal performance. Configuration via simple files. Heracles' ground base handles all the complex logic behind the scenes, allowing developer's to easily create vehicles by simply modifying a couple of variables in their entity script. Flexibility. Almost every function and parameter of Heracles' ground base is set up to provide a high degree of flexibility. Want to add your own code to run every tick? We're got you covered. Want to change the way your vehicle behaves under certain conditions? No problem! All the settings used by the ground base can be easily changed to suit your needs.","title":"Features"},{"location":"overridable_client_functions/","text":"Overridable Functions These functions can be overridden to perform various tasks. While all functions in the ground base can be overridden, it is important to note that ONLY the functions listed here are safe to override. Overriding other functions might lead to broken behaviour when a new update is released. Alongside the function documentation you can find usage examples. ENT:DrawExtra() Click to expand! This function gets executed every frame. If we need to draw any 3D effects, debug information, extra models, lamps, etc. this is the place to do it. function ENT:DrawExtra() end ENT:LFSCalcViewFirstPerson( view, ply ) Click to expand! This function gets executed every frame. We should use it to calculate where we should position our camera in first person. function ENT:LFSCalcViewFirstPerson( view, ply ) local Driver, Gunner = self:GetDriver(), self:GetTurretDriver() if ply == Driver then view.origin = self:LocalToWorld( Vector(-65,25,55) ) elseif ply == Gunner then view.origin = self:LocalToWorld( Vector(-100,0,95) ) else view.origin = self:LocalToWorld( Vector(-65,-25,55) ) end return view end ENT:LFSCalcViewThirdPerson( view, ply, FirstPerson ) Click to expand! This function gets executed every frame. We should use it to calculate where we should position our camera in third person. function ENT:LFSCalcViewThirdPerson( view, ply, FirstPerson ) local Pod = ply:GetVehicle() if ply == self:GetTurretDriver() then local radius = 800 radius = radius + radius * Pod:GetCameraDistance() local StartPos = self:LocalToWorld( Vector(-130.360611,0,111.885109) ) + view.angles:Up() * 100 local EndPos = StartPos - view.angles:Forward() * radius local WallOffset = 4 local tr = util.TraceHull( { start = StartPos, endpos = EndPos, filter = function( e ) local c = e:GetClass() local collide = not c:StartWith( \"prop_physics\" ) and not c:StartWith( \"prop_dynamic\" ) and not c:StartWith( \"prop_ragdoll\" ) and not e:IsVehicle() and not c:StartWith( \"gmod_\" ) and not c:StartWith( \"player\" ) and not e.LFS return collide end, mins = Vector( -WallOffset, -WallOffset, -WallOffset ), maxs = Vector( WallOffset, WallOffset, WallOffset ), } ) view.drawviewer = true view.origin = tr.HitPos if tr.Hit and not tr.StartSolid then view.origin = view.origin + tr.HitNormal * WallOffset end end return view end ENT:LFSHudPaintInfoText( X, Y, speed, alt, AmmoPrimary, AmmoSecondary, Throttle ) Click to expand! This function gets executed every frame. We should use it to draw the HUD for the driver of the vehicle. function ENT:LFSHudPaintInfoText( X, Y, speed, alt, AmmoPrimary, AmmoSecondary, Throttle ) draw.SimpleText( \"SPEED\", \"LFS_FONT\", 10, 10, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP ) draw.SimpleText( speed..\"km/h\", \"LFS_FONT\", 120, 10, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP ) draw.SimpleText( \"PRI\", \"LFS_FONT\", 10, 35, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP ) draw.SimpleText( AmmoPrimary, \"LFS_FONT\", 120, 35, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP ) draw.SimpleText( \"SEC\", \"LFS_FONT\", 10, 60, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP ) draw.SimpleText( AmmoSecondary, \"LFS_FONT\", 120, 60, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP ) end ENT:LFSHudPaintInfoText( X, Y, speed, alt, AmmoPrimary, AmmoSecondary, Throttle ) Click to expand! This function gets executed every frame. We should use it to draw the HUD for the driver of the vehicle. function ENT:LFSHudPaintInfoText( X, Y, speed, alt, AmmoPrimary, AmmoSecondary, Throttle ) draw.SimpleText( \"SPEED\", \"LFS_FONT\", 10, 10, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP ) draw.SimpleText( speed..\"km/h\", \"LFS_FONT\", 120, 10, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP ) draw.SimpleText( \"PRI\", \"LFS_FONT\", 10, 35, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP ) draw.SimpleText( AmmoPrimary, \"LFS_FONT\", 120, 35, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP ) draw.SimpleText( \"SEC\", \"LFS_FONT\", 10, 60, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP ) draw.SimpleText( AmmoSecondary, \"LFS_FONT\", 120, 60, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP ) end ENT:LFSHudPaintPassenger( X, Y, ply ) Click to expand! This function gets executed every frame. We should use it to draw the HUD for any of the passengers of the vehicle. Here is where you should handle the HUD for the turret operator/gunner. function ENT:LFSHudPaintPassenger( X, Y, ply ) if ply == self:GetTurretDriver() then local ID = self:LookupAttachment( \"lazer_cannon_muzzle\" ) local Muzzle = self:GetAttachment( ID ) if Muzzle then local startpos = Muzzle.Pos local Trace = util.TraceHull( { start = startpos, endpos = (startpos + Muzzle.Ang:Up() * 50000), mins = Vector( -10, -10, -10 ), maxs = Vector( 10, 10, 10 ), filter = function( ent ) if ent == self or ent:GetClass() == \"lunasflightschool_missile\" then return false end return true end } ) local HitPos = Trace.HitPos:ToScreen() local X = HitPos.x local Y = HitPos.y if self:GetIsCarried() then surface.SetDrawColor( 255, 0, 0, 255 ) else surface.SetDrawColor( 255, 255, 255, 255 ) end simfphys.LFS.DrawCircle( X, Y, 10 ) surface.DrawLine( X + 10, Y, X + 20, Y ) surface.DrawLine( X - 10, Y, X - 20, Y ) surface.DrawLine( X, Y + 10, X, Y + 20 ) surface.DrawLine( X, Y - 10, X, Y - 20 ) -- shadow surface.SetDrawColor( 0, 0, 0, 80 ) simfphys.LFS.DrawCircle( X + 1, Y + 1, 10 ) surface.DrawLine( X + 11, Y + 1, X + 21, Y + 1 ) surface.DrawLine( X - 9, Y + 1, X - 16, Y + 1 ) surface.DrawLine( X + 1, Y + 11, X + 1, Y + 21 ) surface.DrawLine( X + 1, Y - 19, X + 1, Y - 16 ) end end end","title":"Overridable Functions"},{"location":"overridable_client_functions/#overridable-functions","text":"These functions can be overridden to perform various tasks. While all functions in the ground base can be overridden, it is important to note that ONLY the functions listed here are safe to override. Overriding other functions might lead to broken behaviour when a new update is released. Alongside the function documentation you can find usage examples.","title":"Overridable Functions"},{"location":"overridable_client_functions/#entdrawextra","text":"Click to expand! This function gets executed every frame. If we need to draw any 3D effects, debug information, extra models, lamps, etc. this is the place to do it. function ENT:DrawExtra() end","title":"ENT:DrawExtra()"},{"location":"overridable_client_functions/#entlfscalcviewfirstperson-view-ply","text":"Click to expand! This function gets executed every frame. We should use it to calculate where we should position our camera in first person. function ENT:LFSCalcViewFirstPerson( view, ply ) local Driver, Gunner = self:GetDriver(), self:GetTurretDriver() if ply == Driver then view.origin = self:LocalToWorld( Vector(-65,25,55) ) elseif ply == Gunner then view.origin = self:LocalToWorld( Vector(-100,0,95) ) else view.origin = self:LocalToWorld( Vector(-65,-25,55) ) end return view end","title":"ENT:LFSCalcViewFirstPerson( view, ply )"},{"location":"overridable_client_functions/#entlfscalcviewthirdperson-view-ply-firstperson","text":"Click to expand! This function gets executed every frame. We should use it to calculate where we should position our camera in third person. function ENT:LFSCalcViewThirdPerson( view, ply, FirstPerson ) local Pod = ply:GetVehicle() if ply == self:GetTurretDriver() then local radius = 800 radius = radius + radius * Pod:GetCameraDistance() local StartPos = self:LocalToWorld( Vector(-130.360611,0,111.885109) ) + view.angles:Up() * 100 local EndPos = StartPos - view.angles:Forward() * radius local WallOffset = 4 local tr = util.TraceHull( { start = StartPos, endpos = EndPos, filter = function( e ) local c = e:GetClass() local collide = not c:StartWith( \"prop_physics\" ) and not c:StartWith( \"prop_dynamic\" ) and not c:StartWith( \"prop_ragdoll\" ) and not e:IsVehicle() and not c:StartWith( \"gmod_\" ) and not c:StartWith( \"player\" ) and not e.LFS return collide end, mins = Vector( -WallOffset, -WallOffset, -WallOffset ), maxs = Vector( WallOffset, WallOffset, WallOffset ), } ) view.drawviewer = true view.origin = tr.HitPos if tr.Hit and not tr.StartSolid then view.origin = view.origin + tr.HitNormal * WallOffset end end return view end","title":"ENT:LFSCalcViewThirdPerson( view, ply, FirstPerson )"},{"location":"overridable_client_functions/#entlfshudpaintinfotext-x-y-speed-alt-ammoprimary-ammosecondary-throttle","text":"Click to expand! This function gets executed every frame. We should use it to draw the HUD for the driver of the vehicle. function ENT:LFSHudPaintInfoText( X, Y, speed, alt, AmmoPrimary, AmmoSecondary, Throttle ) draw.SimpleText( \"SPEED\", \"LFS_FONT\", 10, 10, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP ) draw.SimpleText( speed..\"km/h\", \"LFS_FONT\", 120, 10, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP ) draw.SimpleText( \"PRI\", \"LFS_FONT\", 10, 35, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP ) draw.SimpleText( AmmoPrimary, \"LFS_FONT\", 120, 35, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP ) draw.SimpleText( \"SEC\", \"LFS_FONT\", 10, 60, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP ) draw.SimpleText( AmmoSecondary, \"LFS_FONT\", 120, 60, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP ) end","title":"ENT:LFSHudPaintInfoText( X, Y, speed, alt, AmmoPrimary, AmmoSecondary, Throttle )"},{"location":"overridable_client_functions/#entlfshudpaintinfotext-x-y-speed-alt-ammoprimary-ammosecondary-throttle_1","text":"Click to expand! This function gets executed every frame. We should use it to draw the HUD for the driver of the vehicle. function ENT:LFSHudPaintInfoText( X, Y, speed, alt, AmmoPrimary, AmmoSecondary, Throttle ) draw.SimpleText( \"SPEED\", \"LFS_FONT\", 10, 10, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP ) draw.SimpleText( speed..\"km/h\", \"LFS_FONT\", 120, 10, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP ) draw.SimpleText( \"PRI\", \"LFS_FONT\", 10, 35, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP ) draw.SimpleText( AmmoPrimary, \"LFS_FONT\", 120, 35, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP ) draw.SimpleText( \"SEC\", \"LFS_FONT\", 10, 60, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP ) draw.SimpleText( AmmoSecondary, \"LFS_FONT\", 120, 60, Color(255,255,255,255), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP ) end","title":"ENT:LFSHudPaintInfoText( X, Y, speed, alt, AmmoPrimary, AmmoSecondary, Throttle )"},{"location":"overridable_client_functions/#entlfshudpaintpassenger-x-y-ply","text":"Click to expand! This function gets executed every frame. We should use it to draw the HUD for any of the passengers of the vehicle. Here is where you should handle the HUD for the turret operator/gunner. function ENT:LFSHudPaintPassenger( X, Y, ply ) if ply == self:GetTurretDriver() then local ID = self:LookupAttachment( \"lazer_cannon_muzzle\" ) local Muzzle = self:GetAttachment( ID ) if Muzzle then local startpos = Muzzle.Pos local Trace = util.TraceHull( { start = startpos, endpos = (startpos + Muzzle.Ang:Up() * 50000), mins = Vector( -10, -10, -10 ), maxs = Vector( 10, 10, 10 ), filter = function( ent ) if ent == self or ent:GetClass() == \"lunasflightschool_missile\" then return false end return true end } ) local HitPos = Trace.HitPos:ToScreen() local X = HitPos.x local Y = HitPos.y if self:GetIsCarried() then surface.SetDrawColor( 255, 0, 0, 255 ) else surface.SetDrawColor( 255, 255, 255, 255 ) end simfphys.LFS.DrawCircle( X, Y, 10 ) surface.DrawLine( X + 10, Y, X + 20, Y ) surface.DrawLine( X - 10, Y, X - 20, Y ) surface.DrawLine( X, Y + 10, X, Y + 20 ) surface.DrawLine( X, Y - 10, X, Y - 20 ) -- shadow surface.SetDrawColor( 0, 0, 0, 80 ) simfphys.LFS.DrawCircle( X + 1, Y + 1, 10 ) surface.DrawLine( X + 11, Y + 1, X + 21, Y + 1 ) surface.DrawLine( X - 9, Y + 1, X - 16, Y + 1 ) surface.DrawLine( X + 1, Y + 11, X + 1, Y + 21 ) surface.DrawLine( X + 1, Y - 19, X + 1, Y - 16 ) end end end","title":"ENT:LFSHudPaintPassenger( X, Y, ply )"},{"location":"overridable_server_functions/","text":"Overridable Functions These functions can be overridden to perform various tasks. While all functions in the ground base can be overridden, it is important to note that ONLY the functions listed here are safe to override. Overriding other functions might lead to broken behaviour when a new update is released. Alongside the function documentation you can find usage examples. ENT:RunOnSpawn() Click to expand! This function gets executed when we spawn the vehicle. In here you should handle the spawning of any extra seats, assign turret operators and gunners, as well as anything else that needs to happen on spawn. function ENT:RunOnSpawn() local TurretSeat = self:AddPassengerSeat( Vector(0,0,0), Angle(0,-90,0) ) -- Create a new seat self:SetTurretSeat( TurretSeat ) -- Set the seat as the turret operator's seat local ID = self:LookupAttachment( \"driver_turret\" ) local Attachment = self:GetAttachment( ID ) if Attachment then local Pos,Ang = LocalToWorld( Vector(0,-60,0), Angle(180,0,-90), Attachment.Pos, Attachment.Ang ) TurretSeat:SetParent( NULL ) TurretSeat:SetPos( Pos ) TurretSeat:SetAngles( Ang ) TurretSeat:SetParent( self, ID ) -- Parent the seat to the \"driver_turret\" attachment. This is especially useful when the turret operator needs to rotate with the turret end self:AddPassengerSeat( Vector(-68,-23,18), Angle(0,-90,15) ) -- Add a normal passenger's seat. We could also parent this seat to a bone or an attachment end ENT:OnKeyThrottle( bPressed ) Click to expand! This function gets executed when we press the throttle key (default FORWARD). function ENT:OnKeyThrottle( bPressed ) end ENT:OnLandingGearToggled( bOn ) Click to expand! This function gets executed when we press the landing gear key (default SPACE). It is particularly useful if you want the vehicle to deploy and stow certain parts of itself, like missile launchers, or if you want to toggle lights. function ENT:OnLandingGearToggled( bOn ) if bOn then self:PlayAnimation( \"rocket_hatch_open\" ) else self:PlayAnimation( \"rocket_hatch_close\" ) end end ENT:PrimaryAttack() Click to expand! This function gets executed when we press the primary fire key (default LMB) **as the driver of the vehicle**. This is where you should handle your weapon firing logic, such as creating bullets, doing ray casts, etc. function ENT:PrimaryAttack() Pod = self:GetDriverSeat() if not IsValid( Pod ) then return end Driver = Pod:GetDriver() if not IsValid( Driver ) or Driver:lfsGetInput( \"FREELOOK\" ) then return end if self:GetIsCarried() then return end if not self:CanPrimaryAttack() or not self.MainGunDir then return end local ID_L = self:LookupAttachment( \"muzzle_left\" ) local ID_R = self:LookupAttachment( \"muzzle_right\" ) local MuzzleL = self:GetAttachment( ID_L ) local MuzzleR = self:GetAttachment( ID_R ) if not MuzzleL or not MuzzleR then return end local FirePos = { [1] = MuzzleL, [2] = MuzzleR, } self.FireIndexMainWeapon = self.FireIndexMainWeapon and self.FireIndexMainWeapon + 1 or 1 if self.FireIndexMainWeapon > #FirePos then -- This bit of code iterates through all the launchers and fires one at a time. self.FireIndexMainWeapon = 1 self:SetNextPrimary( 0.3 ) -- Take 0.3 seconds between shots. else if self.FireIndexMainWeapon == #FirePos then self:SetNextPrimary( 0.3 ) -- We don't simulate any reloads or cool-downs, just keep firing at the same interval after we cycle through all guns else self:SetNextPrimary( 0.3 ) end end self:EmitSound( \"FIRE\" ) local Pos = FirePos[self.FireIndexMainWeapon].Pos local Dir = FirePos[self.FireIndexMainWeapon].Ang:Up() if math.deg( math.acos( math.Clamp( Dir:Dot( self.MainGunDir ) ,-1,1) ) ) < 8 then Dir = self.MainGunDir end local bullet = {} bullet.Num = 1 bullet.Src = Pos bullet.Dir = Dir bullet.Spread = Vector( 0.01, 0.01, 0 ) bullet.Tracer = 1 bullet.TracerName = \"lfs_laser_red\" bullet.Force = 100 bullet.HullSize = 2 bullet.Damage = 25 bullet.Attacker = self:GetDriver() bullet.AmmoType = \"Pistol\" bullet.Callback = function(att, tr, dmginfo) if tr.Entity.IsSimfphyscar then dmginfo:SetDamageType(DMG_DIRECT) else dmginfo:SetDamageType(DMG_AIRBOAT) end end self:FireBullets( bullet ) self:TakePrimaryAmmo() if self:GetAmmoPrimary() <= 0 then self:EmitSound(\"CANNON_DEACTIVATE\") end end ENT:SecondaryAttack() Click to expand! This function gets executed when we press the secondary fire key (default RMB) **as the driver of the vehicle**. This is where you should handle your secondary weapon firing logic, such as spawning rockets, creating beam lasers, etc. function ENT:SecondaryAttack() if self:GetIsCarried() then return end if not self:CanAltSecondaryAttack() or not self.MainGunDir then return end local ID1 = self:LookupAttachment( \"left_launch_tube_1\" ) local ID2 = self:LookupAttachment( \"right_launch_tube_1\" ) local ID3 = self:LookupAttachment( \"left_launch_tube_2\" ) local ID4 = self:LookupAttachment( \"right_launch_tube_2\" ) local ID5 = self:LookupAttachment( \"left_launch_tube_3\" ) local ID6 = self:LookupAttachment( \"right_launch_tube_3\" ) local ID7 = self:LookupAttachment( \"left_launch_tube_4\" ) local ID8 = self:LookupAttachment( \"right_launch_tube_4\" ) local ID9 = self:LookupAttachment( \"left_launch_tube_5\" ) local ID10 = self:LookupAttachment( \"right_launch_tube_5\" ) local Muzzle1 = self:GetAttachment( ID1 ) local Muzzle2 = self:GetAttachment( ID2 ) local Muzzle3 = self:GetAttachment( ID3 ) local Muzzle4 = self:GetAttachment( ID4 ) local Muzzle5 = self:GetAttachment( ID5 ) local Muzzle6 = self:GetAttachment( ID6 ) local Muzzle7 = self:GetAttachment( ID7 ) local Muzzle8 = self:GetAttachment( ID8 ) local Muzzle9 = self:GetAttachment( ID9 ) local Muzzle10 = self:GetAttachment( ID10 ) if not Muzzle1 or not Muzzle2 or not Muzzle3 or not Muzzle4 or not Muzzle5 or not Muzzle6 or not Muzzle7 or not Muzzle8 or not Muzzle9 or not Muzzle10 then return end local FirePos = { [1] = Muzzle1, [2] = Muzzle2, [3] = Muzzle3, [4] = Muzzle4, [5] = Muzzle5, [6] = Muzzle6, [7] = Muzzle7, [8] = Muzzle8, [9] = Muzzle9, [10] = Muzzle10, } self.FireIndexMissiles = self.FireIndexMissiles and self.FireIndexMissiles + 1 or 1 if self.FireIndexMissiles > #FirePos then -- This bit of code iterates through all the launchers and fires one at a time. self.FireIndexMissiles = 1 self:SetNextAltSecondary( 1 ) -- Take a second between shots. else if self.FireIndexMissiles == #FirePos then self:SetNextAltSecondary( 6 ) -- Once we have cycled through all launchers take 6 seconds before we can fire again. Simulates a \"reload\" or \"cool-down\" of sorts else self:SetNextAltSecondary( 1 ) end end self:EmitSound( \"ROCKET\" ) local Pos = FirePos[self.FireIndexMissiles].Pos local Dir = FirePos[self.FireIndexMissiles].Ang:Up() if math.deg( math.acos( math.Clamp( Dir:Dot( self.MainGunDir ) ,-1,1) ) ) < 8 then Dir = self.MainGunDir end local ent = ents.Create( \"lunasflightschool_tx130_missile\" ) ent:SetPos( Pos ) ent:SetAngles( Dir:Angle() ) ent:Spawn() ent:Activate() ent:SetAttacker( self:GetTurretDriver() ) ent:SetInflictor( self ) constraint.NoCollide( ent, self, 0, 0 ) self:TakeSecondaryAmmo() end ENT:MainGunPoser() Click to expand! This function gets executed every tick. We should use it to position the guns relative to where we are looking at. The following example demonstrates how we can make guns converge on our aiming reticule. Please note that this is **NOT** where we need to pose turrets or guns controlled by a seat other than the driver's (unless we want to slave those things to the driver's seat). function ENT:MainGunPoser( EyeAngles ) self.MainGunDir = EyeAngles:Forward() local startpos = self:GetRotorPos() local TracePlane = util.TraceHull( { start = startpos, endpos = (startpos + self.MainGunDir * 50000), mins = Vector( -10, -10, -10 ), maxs = Vector( 10, 10, 10 ), filter = {self} } ) local AimAnglesG = self:WorldToLocalAngles( (TracePlane.HitPos - self:LocalToWorld( Vector(-5,51,43) ) ):GetNormalized():Angle() ) local AimAnglesL = self:WorldToLocalAngles( (TracePlane.HitPos - self:LocalToWorld( Vector(5,51,43) ) ):GetNormalized():Angle() ) local AimAnglesR = self:WorldToLocalAngles( (TracePlane.HitPos - self:LocalToWorld( Vector(5,-51,43) ) ):GetNormalized():Angle() ) self:SetPoseParameter(\"sidegun_pitch\", AimAnglesG.p ) self:SetPoseParameter(\"sidegun_left_yaw\", AimAnglesL.y ) self:SetPoseParameter(\"sidegun_right_yaw\", AimAnglesR.y ) local ID = self:LookupAttachment( \"muzzle_left\" ) local Muzzle = self:GetAttachment( ID ) if Muzzle then self:SetFrontInRange( math.deg( math.acos( math.Clamp( Muzzle.Ang:Up():Dot( self.MainGunDir ) ,-1,1) ) ) < 15 ) end end ENT:OnTickExtra() Click to expand! This function gets executed every tick. If we need to do anything on every tick not related to turrets or guns, this is the indicated place. function ENT:OnTickExtra() end ENT:Turret( Driver, Pod ) Click to expand! This function gets executed every tick. We should use it to position the turret relative to where the operator is looking at. This is also the place where we need to handle the firing action of the turret. The following example demonstrates how we can make guns converge on our aiming reticule. function ENT:Turret( Driver, Pod ) if not IsValid( Pod ) or not IsValid( Driver ) then -- This is a good way of making a turret controllable by both the turret operator and the driver Pod = self:GetDriverSeat() -- If there is no turret operator present, we switch control to the vehicle's driver if not IsValid( Pod ) then return end Driver = Pod:GetDriver() if not IsValid( Driver ) or not Driver:lfsGetInput( \"FREELOOK\" ) then return end -- Only if the driver is in FREELOOK mode should he control the turret end local EyeAngles = Pod:WorldToLocalAngles( Driver:EyeAngles() ) local AimDir = EyeAngles:Forward() local KeyAttack = Driver:KeyDown( IN_ATTACK ) local TurretPos = self:GetBonePosition( self:LookupBone( \"turret_yaw\" ) ) local startpos = Pod:GetPos() + EyeAngles:Up() * 100 -- We create a trace from the turret to the operator's aiming position local TracePlane = util.TraceLine( { start = startpos, endpos = (startpos + AimDir * 50000), filter = {self} } ) local Ang = self:WorldToLocalAngles( (TracePlane.HitPos - TurretPos ):GetNormalized():Angle() ) local AimRate = 100 * FrameTime() self.sm_ppmg_pitch = self.sm_ppmg_pitch and math.ApproachAngle( self.sm_ppmg_pitch, Ang.p, AimRate ) or 0 self.sm_ppmg_yaw = self.sm_ppmg_yaw and math.ApproachAngle( self.sm_ppmg_yaw, Ang.y, AimRate ) or 0 local TargetAng = Angle(self.sm_ppmg_pitch,self.sm_ppmg_yaw,0) -- We acquire the necessary turret angles to point towards the operator's cross-hair TargetAng:Normalize() self:SetPoseParameter(\"cannon_pitch\", TargetAng.p ) -- Rotate the turret using pose parameters self:SetPoseParameter(\"cannon_yaw\", TargetAng.y ) if KeyAttack then self:FireTurret( Driver ) -- If the turret's operator presses the primary fire key we run the firing logic end if (self.cFireIndex or 0) > 0 and Driver:KeyDown( IN_RELOAD ) then -- If we fire the whole clip, reload self.cFireIndex = 0 self:SetNextSecondary( 2 ) Pod:EmitSound(\"CANNONRELOAD\") end end ENT:Gunner( Driver, Pod ) Click to expand! This function gets executed every tick. We should use it to position the gunner's weapons relative to where the operator is looking at. This is also the place where we need to handle the firing action of the gunner. It is basically the same as the turret code, but it should be used for any extra guns the vehicle might have (such as rear facing cannons, or a second, smaller calibre turret). function ENT:Gunner( Driver, Pod ) end ENT:OnEngineStarted() Click to expand! This function gets executed when we start the vehicle's engine. We should use it to create engine sounds, as well as handle any changes to the hover height. We could also deploy weapons, turn on lights, etc. Your creativity is the limit. function ENT:OnEngineStarted() self:EmitSound( \"lfs/naboo_n1_starfighter/start.wav\" ) self.HeightOffset = 20 end ENT:OnEngineStopped() Click to expand! This function gets executed when we stop the vehicle's engine. We should use it to create engine sounds, as well as handle any changes to the hover height. We could also stow weapons, turn off lights, etc. Your creativity is the limit (again). function ENT:OnEngineStopped() self:EmitSound( \"lfs/naboo_n1_starfighter/start.wav\" ) self.HeightOffset = 5 end ENT:OnIsCarried( name, old, new ) Click to expand! This function gets executed when another vehicle picks us up. We should use this function to stow all weapons, reset all animations, etc. function ENT:OnIsCarried( name, old, new ) if new == old then return end if new then self:SetPoseParameter(\"sidegun_pitch\", 0 ) self:SetPoseParameter(\"sidegun_left_yaw\", 0 ) self:SetPoseParameter(\"sidegun_right_yaw\", 0 ) self:SetPoseParameter(\"cannon_pitch\", 0 ) self:SetPoseParameter(\"cannon_yaw\", 0 ) self:SetPoseParameter(\"move_x\", 0 ) self:SetPoseParameter(\"move_y\", 0 ) self:SetWeaponOutOfRange( true ) end end","title":"Overridable Functions"},{"location":"overridable_server_functions/#overridable-functions","text":"These functions can be overridden to perform various tasks. While all functions in the ground base can be overridden, it is important to note that ONLY the functions listed here are safe to override. Overriding other functions might lead to broken behaviour when a new update is released. Alongside the function documentation you can find usage examples.","title":"Overridable Functions"},{"location":"overridable_server_functions/#entrunonspawn","text":"Click to expand! This function gets executed when we spawn the vehicle. In here you should handle the spawning of any extra seats, assign turret operators and gunners, as well as anything else that needs to happen on spawn. function ENT:RunOnSpawn() local TurretSeat = self:AddPassengerSeat( Vector(0,0,0), Angle(0,-90,0) ) -- Create a new seat self:SetTurretSeat( TurretSeat ) -- Set the seat as the turret operator's seat local ID = self:LookupAttachment( \"driver_turret\" ) local Attachment = self:GetAttachment( ID ) if Attachment then local Pos,Ang = LocalToWorld( Vector(0,-60,0), Angle(180,0,-90), Attachment.Pos, Attachment.Ang ) TurretSeat:SetParent( NULL ) TurretSeat:SetPos( Pos ) TurretSeat:SetAngles( Ang ) TurretSeat:SetParent( self, ID ) -- Parent the seat to the \"driver_turret\" attachment. This is especially useful when the turret operator needs to rotate with the turret end self:AddPassengerSeat( Vector(-68,-23,18), Angle(0,-90,15) ) -- Add a normal passenger's seat. We could also parent this seat to a bone or an attachment end","title":"ENT:RunOnSpawn()"},{"location":"overridable_server_functions/#entonkeythrottle-bpressed","text":"Click to expand! This function gets executed when we press the throttle key (default FORWARD). function ENT:OnKeyThrottle( bPressed ) end","title":"ENT:OnKeyThrottle( bPressed )"},{"location":"overridable_server_functions/#entonlandinggeartoggled-bon","text":"Click to expand! This function gets executed when we press the landing gear key (default SPACE). It is particularly useful if you want the vehicle to deploy and stow certain parts of itself, like missile launchers, or if you want to toggle lights. function ENT:OnLandingGearToggled( bOn ) if bOn then self:PlayAnimation( \"rocket_hatch_open\" ) else self:PlayAnimation( \"rocket_hatch_close\" ) end end","title":"ENT:OnLandingGearToggled( bOn )"},{"location":"overridable_server_functions/#entprimaryattack","text":"Click to expand! This function gets executed when we press the primary fire key (default LMB) **as the driver of the vehicle**. This is where you should handle your weapon firing logic, such as creating bullets, doing ray casts, etc. function ENT:PrimaryAttack() Pod = self:GetDriverSeat() if not IsValid( Pod ) then return end Driver = Pod:GetDriver() if not IsValid( Driver ) or Driver:lfsGetInput( \"FREELOOK\" ) then return end if self:GetIsCarried() then return end if not self:CanPrimaryAttack() or not self.MainGunDir then return end local ID_L = self:LookupAttachment( \"muzzle_left\" ) local ID_R = self:LookupAttachment( \"muzzle_right\" ) local MuzzleL = self:GetAttachment( ID_L ) local MuzzleR = self:GetAttachment( ID_R ) if not MuzzleL or not MuzzleR then return end local FirePos = { [1] = MuzzleL, [2] = MuzzleR, } self.FireIndexMainWeapon = self.FireIndexMainWeapon and self.FireIndexMainWeapon + 1 or 1 if self.FireIndexMainWeapon > #FirePos then -- This bit of code iterates through all the launchers and fires one at a time. self.FireIndexMainWeapon = 1 self:SetNextPrimary( 0.3 ) -- Take 0.3 seconds between shots. else if self.FireIndexMainWeapon == #FirePos then self:SetNextPrimary( 0.3 ) -- We don't simulate any reloads or cool-downs, just keep firing at the same interval after we cycle through all guns else self:SetNextPrimary( 0.3 ) end end self:EmitSound( \"FIRE\" ) local Pos = FirePos[self.FireIndexMainWeapon].Pos local Dir = FirePos[self.FireIndexMainWeapon].Ang:Up() if math.deg( math.acos( math.Clamp( Dir:Dot( self.MainGunDir ) ,-1,1) ) ) < 8 then Dir = self.MainGunDir end local bullet = {} bullet.Num = 1 bullet.Src = Pos bullet.Dir = Dir bullet.Spread = Vector( 0.01, 0.01, 0 ) bullet.Tracer = 1 bullet.TracerName = \"lfs_laser_red\" bullet.Force = 100 bullet.HullSize = 2 bullet.Damage = 25 bullet.Attacker = self:GetDriver() bullet.AmmoType = \"Pistol\" bullet.Callback = function(att, tr, dmginfo) if tr.Entity.IsSimfphyscar then dmginfo:SetDamageType(DMG_DIRECT) else dmginfo:SetDamageType(DMG_AIRBOAT) end end self:FireBullets( bullet ) self:TakePrimaryAmmo() if self:GetAmmoPrimary() <= 0 then self:EmitSound(\"CANNON_DEACTIVATE\") end end","title":"ENT:PrimaryAttack()"},{"location":"overridable_server_functions/#entsecondaryattack","text":"Click to expand! This function gets executed when we press the secondary fire key (default RMB) **as the driver of the vehicle**. This is where you should handle your secondary weapon firing logic, such as spawning rockets, creating beam lasers, etc. function ENT:SecondaryAttack() if self:GetIsCarried() then return end if not self:CanAltSecondaryAttack() or not self.MainGunDir then return end local ID1 = self:LookupAttachment( \"left_launch_tube_1\" ) local ID2 = self:LookupAttachment( \"right_launch_tube_1\" ) local ID3 = self:LookupAttachment( \"left_launch_tube_2\" ) local ID4 = self:LookupAttachment( \"right_launch_tube_2\" ) local ID5 = self:LookupAttachment( \"left_launch_tube_3\" ) local ID6 = self:LookupAttachment( \"right_launch_tube_3\" ) local ID7 = self:LookupAttachment( \"left_launch_tube_4\" ) local ID8 = self:LookupAttachment( \"right_launch_tube_4\" ) local ID9 = self:LookupAttachment( \"left_launch_tube_5\" ) local ID10 = self:LookupAttachment( \"right_launch_tube_5\" ) local Muzzle1 = self:GetAttachment( ID1 ) local Muzzle2 = self:GetAttachment( ID2 ) local Muzzle3 = self:GetAttachment( ID3 ) local Muzzle4 = self:GetAttachment( ID4 ) local Muzzle5 = self:GetAttachment( ID5 ) local Muzzle6 = self:GetAttachment( ID6 ) local Muzzle7 = self:GetAttachment( ID7 ) local Muzzle8 = self:GetAttachment( ID8 ) local Muzzle9 = self:GetAttachment( ID9 ) local Muzzle10 = self:GetAttachment( ID10 ) if not Muzzle1 or not Muzzle2 or not Muzzle3 or not Muzzle4 or not Muzzle5 or not Muzzle6 or not Muzzle7 or not Muzzle8 or not Muzzle9 or not Muzzle10 then return end local FirePos = { [1] = Muzzle1, [2] = Muzzle2, [3] = Muzzle3, [4] = Muzzle4, [5] = Muzzle5, [6] = Muzzle6, [7] = Muzzle7, [8] = Muzzle8, [9] = Muzzle9, [10] = Muzzle10, } self.FireIndexMissiles = self.FireIndexMissiles and self.FireIndexMissiles + 1 or 1 if self.FireIndexMissiles > #FirePos then -- This bit of code iterates through all the launchers and fires one at a time. self.FireIndexMissiles = 1 self:SetNextAltSecondary( 1 ) -- Take a second between shots. else if self.FireIndexMissiles == #FirePos then self:SetNextAltSecondary( 6 ) -- Once we have cycled through all launchers take 6 seconds before we can fire again. Simulates a \"reload\" or \"cool-down\" of sorts else self:SetNextAltSecondary( 1 ) end end self:EmitSound( \"ROCKET\" ) local Pos = FirePos[self.FireIndexMissiles].Pos local Dir = FirePos[self.FireIndexMissiles].Ang:Up() if math.deg( math.acos( math.Clamp( Dir:Dot( self.MainGunDir ) ,-1,1) ) ) < 8 then Dir = self.MainGunDir end local ent = ents.Create( \"lunasflightschool_tx130_missile\" ) ent:SetPos( Pos ) ent:SetAngles( Dir:Angle() ) ent:Spawn() ent:Activate() ent:SetAttacker( self:GetTurretDriver() ) ent:SetInflictor( self ) constraint.NoCollide( ent, self, 0, 0 ) self:TakeSecondaryAmmo() end","title":"ENT:SecondaryAttack()"},{"location":"overridable_server_functions/#entmaingunposer","text":"Click to expand! This function gets executed every tick. We should use it to position the guns relative to where we are looking at. The following example demonstrates how we can make guns converge on our aiming reticule. Please note that this is **NOT** where we need to pose turrets or guns controlled by a seat other than the driver's (unless we want to slave those things to the driver's seat). function ENT:MainGunPoser( EyeAngles ) self.MainGunDir = EyeAngles:Forward() local startpos = self:GetRotorPos() local TracePlane = util.TraceHull( { start = startpos, endpos = (startpos + self.MainGunDir * 50000), mins = Vector( -10, -10, -10 ), maxs = Vector( 10, 10, 10 ), filter = {self} } ) local AimAnglesG = self:WorldToLocalAngles( (TracePlane.HitPos - self:LocalToWorld( Vector(-5,51,43) ) ):GetNormalized():Angle() ) local AimAnglesL = self:WorldToLocalAngles( (TracePlane.HitPos - self:LocalToWorld( Vector(5,51,43) ) ):GetNormalized():Angle() ) local AimAnglesR = self:WorldToLocalAngles( (TracePlane.HitPos - self:LocalToWorld( Vector(5,-51,43) ) ):GetNormalized():Angle() ) self:SetPoseParameter(\"sidegun_pitch\", AimAnglesG.p ) self:SetPoseParameter(\"sidegun_left_yaw\", AimAnglesL.y ) self:SetPoseParameter(\"sidegun_right_yaw\", AimAnglesR.y ) local ID = self:LookupAttachment( \"muzzle_left\" ) local Muzzle = self:GetAttachment( ID ) if Muzzle then self:SetFrontInRange( math.deg( math.acos( math.Clamp( Muzzle.Ang:Up():Dot( self.MainGunDir ) ,-1,1) ) ) < 15 ) end end","title":"ENT:MainGunPoser()"},{"location":"overridable_server_functions/#entontickextra","text":"Click to expand! This function gets executed every tick. If we need to do anything on every tick not related to turrets or guns, this is the indicated place. function ENT:OnTickExtra() end","title":"ENT:OnTickExtra()"},{"location":"overridable_server_functions/#entturret-driver-pod","text":"Click to expand! This function gets executed every tick. We should use it to position the turret relative to where the operator is looking at. This is also the place where we need to handle the firing action of the turret. The following example demonstrates how we can make guns converge on our aiming reticule. function ENT:Turret( Driver, Pod ) if not IsValid( Pod ) or not IsValid( Driver ) then -- This is a good way of making a turret controllable by both the turret operator and the driver Pod = self:GetDriverSeat() -- If there is no turret operator present, we switch control to the vehicle's driver if not IsValid( Pod ) then return end Driver = Pod:GetDriver() if not IsValid( Driver ) or not Driver:lfsGetInput( \"FREELOOK\" ) then return end -- Only if the driver is in FREELOOK mode should he control the turret end local EyeAngles = Pod:WorldToLocalAngles( Driver:EyeAngles() ) local AimDir = EyeAngles:Forward() local KeyAttack = Driver:KeyDown( IN_ATTACK ) local TurretPos = self:GetBonePosition( self:LookupBone( \"turret_yaw\" ) ) local startpos = Pod:GetPos() + EyeAngles:Up() * 100 -- We create a trace from the turret to the operator's aiming position local TracePlane = util.TraceLine( { start = startpos, endpos = (startpos + AimDir * 50000), filter = {self} } ) local Ang = self:WorldToLocalAngles( (TracePlane.HitPos - TurretPos ):GetNormalized():Angle() ) local AimRate = 100 * FrameTime() self.sm_ppmg_pitch = self.sm_ppmg_pitch and math.ApproachAngle( self.sm_ppmg_pitch, Ang.p, AimRate ) or 0 self.sm_ppmg_yaw = self.sm_ppmg_yaw and math.ApproachAngle( self.sm_ppmg_yaw, Ang.y, AimRate ) or 0 local TargetAng = Angle(self.sm_ppmg_pitch,self.sm_ppmg_yaw,0) -- We acquire the necessary turret angles to point towards the operator's cross-hair TargetAng:Normalize() self:SetPoseParameter(\"cannon_pitch\", TargetAng.p ) -- Rotate the turret using pose parameters self:SetPoseParameter(\"cannon_yaw\", TargetAng.y ) if KeyAttack then self:FireTurret( Driver ) -- If the turret's operator presses the primary fire key we run the firing logic end if (self.cFireIndex or 0) > 0 and Driver:KeyDown( IN_RELOAD ) then -- If we fire the whole clip, reload self.cFireIndex = 0 self:SetNextSecondary( 2 ) Pod:EmitSound(\"CANNONRELOAD\") end end","title":"ENT:Turret( Driver, Pod )"},{"location":"overridable_server_functions/#entgunner-driver-pod","text":"Click to expand! This function gets executed every tick. We should use it to position the gunner's weapons relative to where the operator is looking at. This is also the place where we need to handle the firing action of the gunner. It is basically the same as the turret code, but it should be used for any extra guns the vehicle might have (such as rear facing cannons, or a second, smaller calibre turret). function ENT:Gunner( Driver, Pod ) end","title":"ENT:Gunner( Driver, Pod )"},{"location":"overridable_server_functions/#entonenginestarted","text":"Click to expand! This function gets executed when we start the vehicle's engine. We should use it to create engine sounds, as well as handle any changes to the hover height. We could also deploy weapons, turn on lights, etc. Your creativity is the limit. function ENT:OnEngineStarted() self:EmitSound( \"lfs/naboo_n1_starfighter/start.wav\" ) self.HeightOffset = 20 end","title":"ENT:OnEngineStarted()"},{"location":"overridable_server_functions/#entonenginestopped","text":"Click to expand! This function gets executed when we stop the vehicle's engine. We should use it to create engine sounds, as well as handle any changes to the hover height. We could also stow weapons, turn off lights, etc. Your creativity is the limit (again). function ENT:OnEngineStopped() self:EmitSound( \"lfs/naboo_n1_starfighter/start.wav\" ) self.HeightOffset = 5 end","title":"ENT:OnEngineStopped()"},{"location":"overridable_server_functions/#entoniscarried-name-old-new","text":"Click to expand! This function gets executed when another vehicle picks us up. We should use this function to stow all weapons, reset all animations, etc. function ENT:OnIsCarried( name, old, new ) if new == old then return end if new then self:SetPoseParameter(\"sidegun_pitch\", 0 ) self:SetPoseParameter(\"sidegun_left_yaw\", 0 ) self:SetPoseParameter(\"sidegun_right_yaw\", 0 ) self:SetPoseParameter(\"cannon_pitch\", 0 ) self:SetPoseParameter(\"cannon_yaw\", 0 ) self:SetPoseParameter(\"move_x\", 0 ) self:SetPoseParameter(\"move_y\", 0 ) self:SetWeaponOutOfRange( true ) end end","title":"ENT:OnIsCarried( name, old, new )"},{"location":"overview/","text":"Overview Welcome to the Heracles' LFS Ground Vehicle Base documentation. If new to the base, start with the features and installation documents . Overview information Features : A high level list of features in the ground base. FAQ : Frequently asked questions. Releases : The history of the ground base releases. Breaking Changes : Recent software changes that may require developers to update their vehicle's files. Developer Documentation Code Overview : Developers should read this first. Debugging : Information on how to test and debug the ground base. Contributing : Information on how to submit improvements to the ground base.","title":"Overview"},{"location":"overview/#overview","text":"Welcome to the Heracles' LFS Ground Vehicle Base documentation. If new to the base, start with the features and installation documents .","title":"Overview"},{"location":"overview/#overview-information","text":"Features : A high level list of features in the ground base. FAQ : Frequently asked questions. Releases : The history of the ground base releases. Breaking Changes : Recent software changes that may require developers to update their vehicle's files.","title":"Overview information"},{"location":"overview/#developer-documentation","text":"Code Overview : Developers should read this first. Debugging : Information on how to test and debug the ground base. Contributing : Information on how to submit improvements to the ground base.","title":"Developer Documentation"},{"location":"shared_lua/","text":"shared.lua Specifying the ground base Click to expand! At the beginning of the file we must specify the entity type as well as it's base class. It is recommended all vehicles use the type \"anim\". We can do so by using the following code: ENT.Type = \"anim\" DEFINE_BASECLASS( \"heracles421_lfs_base\" ) Team Click to expand! Specifying the vehicle's team allows us to see it on the radar as enemy or friend depending on your own team. It also allows the AI to correctly identify targets. ENT.AITEAM = 2 -- We can choose any team from 1 to 3. Make sure to keep the number consistent for vehicles of the same faction! 3rd person view position Click to expand! Specifying the view position for 3rd person camera is crucial, as that is the default view for most vehicles. ENT.RotorPos = Vector(0,0,0) -- This position is relative to the vehicle's origin! Vehicle's model and gib models Click to expand! Specifying the vehicle's model is critical, as that is what people will see when they spawn the vehicle. Gibs are also important, they are the models that get spawned whenever our vehicle gets destroyed. Multiple gibs can be specified if we want to simulate the vehicle falling apart. ENT.MDL = \"models/hunter/blocks/cube1x3x1.mdl\" ENT.GibModels = { \"models/hunter/blocks/cube1x3x1.mdl\", } Driver's seat Click to expand! Specifying the vehicle driver's seat position and rotation is very important. You can do so using the following code: ENT.SeatPos = Vector(0,0,0) ENT.SeatAng = Angle(0,-90,0) Health Click to expand! Specifying the vehicle's health can be done using the following code: ENT.MaxHealth = 2000 Ammo Click to expand! Specifying the vehicle's ammunition can be done using the following code: ENT.MaxPrimaryAmmo = 400 ENT.MaxSecondaryAmmo = 10 Mass Click to expand! Specifying the vehicle's mass can be done using the following code: ENT.Mass = 500 Move speed Click to expand! Specifying the vehicle's mass can be done using the following code: ENT.MoveSpeed = 60 -- Normal movement speed ENT.BoostSpeed = 100 -- Speed when the player is holding the SHIFT key Shadow params Click to expand! Specifying the vehicle's shadow params can tweak how fast it responds to changes in speed, how fast it turns, how much dampening the movement receives, etc. Playing around with these values is a good idea, as it provides fine-tuning for you vehicle's motion. ENT.ShadowParams = { secondstoarrive = 0.001, maxangular = 50, maxangulardamp = 100000, maxspeed = 500, maxspeeddamp = 500000, dampfactor = 1, teleportdistance = 0, } Height offset Click to expand! Specifying the vehicle's height offset (the distance it will hover from the ground) is done using: ENT.HeightOffset = 80 Trace distance Click to expand! Every vehicle utilizes ray casting to check whether it is on the ground, and how far away from the ground it should be hovering. This value specifies the max distance we will cast that ray for. Make sure this value is big enough to handle small terrain imperfections without loosing traction. ENT.TraceDistance = 150 Water affinity Click to expand! Should we treat water as solid ground and allow vehicles to traverse over it? ENT.IgnoreWater = true Movement restrictions Click to expand! Should we allow the vehicle to move laterally? Disabling this is only useful if we are dealing with wheeled or tracked vehicles. Hover vehicles for the most part should be able to move laterally. ENT.CanMoveSideways = true Other settings LERP Click to expand! How smoothly should we move between points when handling locomotion? Value must be between 0 and 1 0 for smoother motion, 1 for snappy motion. Recommended value is 1. ENT.LerpMultiplier = 1 ENT.ZLerpMultiplier = ENT.LerpMultiplier Inertia Click to expand! How much inertia should we keep once we land if the vehicle lifts off the ground? This value needs to be small, otherwise the vehicle will be shot away at a great, uncontrollable speed. ENT.InertiaMultiplier = 0.1 Look Ahead Click to expand! How much should look ahead for terrain when moving fast. This is useful for fast moving vehicles, as it prevents them from nose diving into the ground. This won't prevent you from crashing when the angle change is very steep, but it will help with smaller angles. ENT.LookAheadMultiplier = 1E-10 -- This value needs to be REALLY small. Like 10^-8 small Trace Subdivision Click to expand! How many ray casts should we perform for this specific vehicle. Please note that this value is **NOT** linear! The amount of ray casts is given by: `(n + 1)^2`, where `n` is the value specified below. It is recommended you don't change this value, unless you're dealing with large vehicles, as more ray casts mean more server lag. ENT.TraceSubdivision = 1 Max Angle Click to expand! What is the max angle relative to the horizon that we can achieve. When the vehicle goes over this angle it looses all grip and falls down. This is useful if you want to make vehicles capable of sticking to the ceiling or to very steep walls. ENT.MaxAngle = 70 Collision Box Multiplier Click to expand! How much should we multiply the vehicle's collision box by when doing ray casts. This is useful if for some reason you want to perform ray casts beyond the vehicle's edges. ENT.HitBoxMultiplier = 1 Trace Time Click to expand! How much time (in seconds) should we wait between ray casts. This setting helps us reduce server lag by performing less ray cast operations without affecting vehicle performance. Slow vehicles don't need to perform ray casts as often as fast vehicles. The default value is good enough for medium-sized vehicles, but tweaking this number can yield better results. ENT.TraceTimeMin = 0.05 Hide Driver Click to expand! Should we visually hide the driver of the vehicle? ENT.HideDriver = false LAAT/c Compatibility Click to expand! For use with LFS' LAAT/c. Should the LAAT/c be able to carry this vehicle? We also define what position and rotation the vehicle will occupy relative to the LAAT/c's pickup point. ENT.LAATC_PICKUPABLE = true ENT.LAATC_PICKUP_POS = Vector(-200,0,30) ENT.LAATC_PICKUP_Angle = Angle(0,0,0)","title":"Shared Lua"},{"location":"shared_lua/#sharedlua","text":"","title":"shared.lua"},{"location":"shared_lua/#specifying-the-ground-base","text":"Click to expand! At the beginning of the file we must specify the entity type as well as it's base class. It is recommended all vehicles use the type \"anim\". We can do so by using the following code: ENT.Type = \"anim\" DEFINE_BASECLASS( \"heracles421_lfs_base\" )","title":"Specifying the ground base"},{"location":"shared_lua/#team","text":"Click to expand! Specifying the vehicle's team allows us to see it on the radar as enemy or friend depending on your own team. It also allows the AI to correctly identify targets. ENT.AITEAM = 2 -- We can choose any team from 1 to 3. Make sure to keep the number consistent for vehicles of the same faction!","title":"Team"},{"location":"shared_lua/#3rd-person-view-position","text":"Click to expand! Specifying the view position for 3rd person camera is crucial, as that is the default view for most vehicles. ENT.RotorPos = Vector(0,0,0) -- This position is relative to the vehicle's origin!","title":"3rd person view position"},{"location":"shared_lua/#vehicles-model-and-gib-models","text":"Click to expand! Specifying the vehicle's model is critical, as that is what people will see when they spawn the vehicle. Gibs are also important, they are the models that get spawned whenever our vehicle gets destroyed. Multiple gibs can be specified if we want to simulate the vehicle falling apart. ENT.MDL = \"models/hunter/blocks/cube1x3x1.mdl\" ENT.GibModels = { \"models/hunter/blocks/cube1x3x1.mdl\", }","title":"Vehicle's model and gib models"},{"location":"shared_lua/#drivers-seat","text":"Click to expand! Specifying the vehicle driver's seat position and rotation is very important. You can do so using the following code: ENT.SeatPos = Vector(0,0,0) ENT.SeatAng = Angle(0,-90,0)","title":"Driver's seat"},{"location":"shared_lua/#health","text":"Click to expand! Specifying the vehicle's health can be done using the following code: ENT.MaxHealth = 2000","title":"Health"},{"location":"shared_lua/#ammo","text":"Click to expand! Specifying the vehicle's ammunition can be done using the following code: ENT.MaxPrimaryAmmo = 400 ENT.MaxSecondaryAmmo = 10","title":"Ammo"},{"location":"shared_lua/#mass","text":"Click to expand! Specifying the vehicle's mass can be done using the following code: ENT.Mass = 500","title":"Mass"},{"location":"shared_lua/#move-speed","text":"Click to expand! Specifying the vehicle's mass can be done using the following code: ENT.MoveSpeed = 60 -- Normal movement speed ENT.BoostSpeed = 100 -- Speed when the player is holding the SHIFT key","title":"Move speed"},{"location":"shared_lua/#shadow-params","text":"Click to expand! Specifying the vehicle's shadow params can tweak how fast it responds to changes in speed, how fast it turns, how much dampening the movement receives, etc. Playing around with these values is a good idea, as it provides fine-tuning for you vehicle's motion. ENT.ShadowParams = { secondstoarrive = 0.001, maxangular = 50, maxangulardamp = 100000, maxspeed = 500, maxspeeddamp = 500000, dampfactor = 1, teleportdistance = 0, }","title":"Shadow params"},{"location":"shared_lua/#height-offset","text":"Click to expand! Specifying the vehicle's height offset (the distance it will hover from the ground) is done using: ENT.HeightOffset = 80","title":"Height offset"},{"location":"shared_lua/#trace-distance","text":"Click to expand! Every vehicle utilizes ray casting to check whether it is on the ground, and how far away from the ground it should be hovering. This value specifies the max distance we will cast that ray for. Make sure this value is big enough to handle small terrain imperfections without loosing traction. ENT.TraceDistance = 150","title":"Trace distance"},{"location":"shared_lua/#water-affinity","text":"Click to expand! Should we treat water as solid ground and allow vehicles to traverse over it? ENT.IgnoreWater = true","title":"Water affinity"},{"location":"shared_lua/#movement-restrictions","text":"Click to expand! Should we allow the vehicle to move laterally? Disabling this is only useful if we are dealing with wheeled or tracked vehicles. Hover vehicles for the most part should be able to move laterally. ENT.CanMoveSideways = true","title":"Movement restrictions"},{"location":"shared_lua/#other-settings","text":"","title":"Other settings"},{"location":"shared_lua/#lerp","text":"Click to expand! How smoothly should we move between points when handling locomotion? Value must be between 0 and 1 0 for smoother motion, 1 for snappy motion. Recommended value is 1. ENT.LerpMultiplier = 1 ENT.ZLerpMultiplier = ENT.LerpMultiplier","title":"LERP"},{"location":"shared_lua/#inertia","text":"Click to expand! How much inertia should we keep once we land if the vehicle lifts off the ground? This value needs to be small, otherwise the vehicle will be shot away at a great, uncontrollable speed. ENT.InertiaMultiplier = 0.1","title":"Inertia"},{"location":"shared_lua/#look-ahead","text":"Click to expand! How much should look ahead for terrain when moving fast. This is useful for fast moving vehicles, as it prevents them from nose diving into the ground. This won't prevent you from crashing when the angle change is very steep, but it will help with smaller angles. ENT.LookAheadMultiplier = 1E-10 -- This value needs to be REALLY small. Like 10^-8 small","title":"Look Ahead"},{"location":"shared_lua/#trace-subdivision","text":"Click to expand! How many ray casts should we perform for this specific vehicle. Please note that this value is **NOT** linear! The amount of ray casts is given by: `(n + 1)^2`, where `n` is the value specified below. It is recommended you don't change this value, unless you're dealing with large vehicles, as more ray casts mean more server lag. ENT.TraceSubdivision = 1","title":"Trace Subdivision"},{"location":"shared_lua/#max-angle","text":"Click to expand! What is the max angle relative to the horizon that we can achieve. When the vehicle goes over this angle it looses all grip and falls down. This is useful if you want to make vehicles capable of sticking to the ceiling or to very steep walls. ENT.MaxAngle = 70","title":"Max Angle"},{"location":"shared_lua/#collision-box-multiplier","text":"Click to expand! How much should we multiply the vehicle's collision box by when doing ray casts. This is useful if for some reason you want to perform ray casts beyond the vehicle's edges. ENT.HitBoxMultiplier = 1","title":"Collision Box Multiplier"},{"location":"shared_lua/#trace-time","text":"Click to expand! How much time (in seconds) should we wait between ray casts. This setting helps us reduce server lag by performing less ray cast operations without affecting vehicle performance. Slow vehicles don't need to perform ray casts as often as fast vehicles. The default value is good enough for medium-sized vehicles, but tweaking this number can yield better results. ENT.TraceTimeMin = 0.05","title":"Trace Time"},{"location":"shared_lua/#hide-driver","text":"Click to expand! Should we visually hide the driver of the vehicle? ENT.HideDriver = false","title":"Hide Driver"},{"location":"shared_lua/#laatc-compatibility","text":"Click to expand! For use with LFS' LAAT/c. Should the LAAT/c be able to carry this vehicle? We also define what position and rotation the vehicle will occupy relative to the LAAT/c's pickup point. ENT.LAATC_PICKUPABLE = true ENT.LAATC_PICKUP_POS = Vector(-200,0,30) ENT.LAATC_PICKUP_Angle = Angle(0,0,0)","title":"LAAT/c Compatibility"}]}